<a name="xqc8A"></a>
# 预备知识
<a name="H7dPK"></a>
## 理解源IP地址和目的IP地址
因特网上的每台计算机都有一个唯一的IP地址，如果一台主机上的数据要传输到另一台主机，那么对端主机的IP地址就应该作为该数据传输时的目的IP地址。但仅仅知道目的IP地址是不够的，当对端主机收到该数据后，对端主机还需要对该主机做出响应，因此对端主机也需要发送数据给该主机，此时对端主机就必须知道该主机的IP地址。因此一个传输的数据当中应该涵盖其源IP地址和目的IP地址，目的IP地址表明该数据传输的目的地，源IP地址作为对端主机响应时的目的IP地址。

在数据进行传输之前，会先自顶向下贯穿网络协议栈完成数据的封装，其中在网络层封装的IP报头当中就涵盖了源IP地址和目的IP地址。而除了源IP地址和目的IP地址之外，还有源MAC地址和目的MAC地址的概念。
<a name="f0s09"></a>
## 理解源MAC地址和目的MAC地址
大部分数据的传输都是跨局域网的，数据在传输过程中会经过若干个路由器，最终才能到达对端主机。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678453188679-41d5a2f8-c559-45a0-b538-1e11943bdaf9.png#averageHue=%23fbfbfb&clientId=u2e10b020-8b48-4&from=paste&height=276&id=uf2d3b0e4&name=image.png&originHeight=345&originWidth=1531&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=74449&status=done&style=none&taskId=u16fefc70-d288-41ef-a146-51cbf9e4b20&title=&width=1224.8)

源MAC地址和目的MAC地址是包含在链路层的报头当中的，而MAC地址实际只在当前局域网内有效，因此当数据跨网络到达另一个局域网时，其源MAC地址和目的MAC地址就需要发生变化，因此当数据达到路由器时，路由器会将该数据当中链路层的报头去掉，然后再重新封装一个报头，此时该数据的源MAC地址和目的MAC地址就发生了变化。

例如，在图中主机１向主机２发送数据的过程中，数据的源MAC地址和目的MAC地址的变化过程如下：

| 时间轴 | 源MAC地址 | 目的MAC地址 |
| --- | --- | --- |
| 刚开始 | 主机1的MAC地址 | 路由器A的MAC地址 |
| 经过路由器A之后 | 路由器A的MAC地址 | 路由器B的MAC地址 |
| 经过路由器B之后 | 路由器B的MAC地址 | 路由器C的MAC地址 |
| 经过路由器C之后 | 路由器C的MAC地址 | 路由器D的MAC地址 |
| 经过路由器D之后 | 路由器D的MAC地址 | 主机2的MAC地址 |


因此数据在传输的过程中是有两套地址：

- 一套是源IP地址和目的IP地址，这两个地址在数据传输过程中基本是不会发生变化的（存在一些特殊情况，比如在数据传输过程中使用NET技术，其源IP地址会发生变化，但至少目的IP地址是不会变化的）。
- 另一套就是源MAC地址和目的MAC地址，这两个地址是一直在发生变化的，因为在数据传输的过程中路由器不断在进行解包和重新封装。

<a name="TJuWf"></a>
## 理解源端口号和目的端口号
首先我们需要明确的是，两台主机之间通信的目的不仅仅是为了将数据发送给对端主机，而是为了访问对端主机上的某个服务。比如我们在用百度搜索引擎进行搜索时，不仅仅是想将我们的请求发送给对端服务器，而是想访问对端服务器上部署的百度相关的搜索服务。

> socket通信的本质

现在通过IP地址和MAC地址已经能够将数据发送到对端主机了，但实际我们是想将数据发送给对端主机上的某个服务进程，此外，数据的发送者也不是主机，而是主机上的某个进程，比如当我们用浏览器访问数据时，实际就是浏览器进程向对端服务进程发起的请求。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678453381370-1029d749-5f1c-436a-8e08-f5536a16256d.png#averageHue=%23f9f9f9&clientId=u2e10b020-8b48-4&from=paste&height=426&id=u3e97d48e&name=image.png&originHeight=533&originWidth=1325&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=81096&status=done&style=none&taskId=u8df3f0cd-2d68-4363-ace9-74d21774164&title=&width=1060)也就是说，socket通信本质上就是两个进程之间在进行通信，只不过这里是跨网络的进程间通信。比如逛淘宝和刷抖音的动作，实际就是手机上的淘宝进程和抖音进程在和对端服务器主机上的淘宝服务进程和抖音服务进程之间在进行通信。

因此进程间通信的方式除了管道、消息队列、信号量、共享内存等方式外，还有套接字，只不过前者是不跨网络的，而后者是跨网络的。

> 端口号


实际在两台主机上，可能会同时存在多个正在进行跨网络通信的进程，因此当数据到达对端主机后，必须要通过某种方法找到该主机上对应的服务进程，然后将数据交给该进程处理。而当该进程处理完数据后还要对发送端进行响应，因此对端主机也需要知道，是发送端上的哪一个进程向它发送的数据请求。

端口号（port）的作用实际就是标识一台主机上的一个进程。

- 端口号是传输层协议的内容。
- 端口号是一个2字节16位的整数。
- 端口号用来标识一个进程，告诉操作系统，当前的这个数据要交给哪一个进程来处理。
- 一个端口号只能被一个进程占用。

由于IP地址能够唯一标识公网内的一台主机，而端口号能够唯一标识一台主机上的一个进程，因此用IP地址+端口号就能够唯一标识网络上的某一台主机的某一个进程。

当数据在传输层进行封装时，就会添加上对应源端口号和目的端口号的信息。这时通过源IP地址+源端口号就能够在网络上唯一标识发送数据的进程，通过目的IP地址+目的端口号就能够在网络上唯一标识接收数据的进程，此时就实现了跨网络的进程间通信。

**注意：** 因为端口号是隶属于某台主机的，所以端口号可以在两台不同的主机当中重复，但是在同一台主机上进行网络通信的进程的端口号不能重复。此外，一个进程可以绑定多个端口号，但是一个端口号不能被多个进程同时绑定。

> 理解socket这个名字


socket在英文上有“插座”的意思，插座上有不同规格的插孔，我们将插头插入到对应的插孔当中就能够实现电流的传输。

在进行网络通信时，客户端就相当于插头，服务端就相当于一个插座，但服务端上可能会有多个不同的服务进程（多个插孔），因此当我们在访问服务时需要指明服务进程的端口号（对应规格的插孔），才能享受对应服务进程的服务。


<a name="lFZoR"></a>
## PORT VS PID

> 端口号（port）的作用唯一标识一台主机上的某个进程，进程ID（PID）的作用也是唯一标识一台主机上的某个进程，那在进行网络通信时为什么不直接用PID来代替port呢？


进程ID（PID）是用来标识系统内所有进程的唯一性的，它是属于系统级的概念；而端口号（port）是用来标识需要对外进行网络数据请求的进程的唯一性的，它是属于网络的概念。

一台机器上可能会有大量的进程，但并不是所有的进程都要进行网络通信，可能有很大一部分的进程是不需要进行网络通信的本地进程，此时PID虽然也可以标识这些网络进程的唯一性，但在该场景下就不太合适了。

比如每个人都有自己的身份证号，身份证号已经可以标识我们的唯一性了，但是当我们到了学校还是会有学号，到了公司还是会有工号。这是为什么呢？为什么不直接用身份证号来代替学号和工号呢？

因为身份证号是国家用于行政管理时用的编号，而学号是学校用于管理学生时用的编号，工号是公司用于管理员工时用的编号。但并不是全中国人都在某所学校或某家公司，因此在学校或公司当中，没必要用身份证号来标识每个人的唯一性。此时就出现了学号和工号，在学号和工号当中还可以包含一些便于管理的信息，比如入学（入职）年份、性别等信息。

也就是说，在不同的场景下可能需要不同的编号来标识某种事物的唯一性，因为这些编号更适合用于该场景。

> 底层如何通过port找到对应进程的？

实际底层采用哈希的方式建立了端口号和进程PID或PCB之间的映射关系，当底层拿到端口号时就可以直接执行对应的哈希算法，然后就能够找到该端口号对应的进程。

<a name="ItW5I"></a>
## 认识TCP协议和UDP协议
网络协议栈是贯穿整个体系结构的，在应用层、操作系统层和驱动层各有一部分。当我们使用系统调用接口实现网络数据通信时，不得不面对的协议层就是传输层，而传输层最典型的两种协议就是TCP协议和UDP协议。

> TCP协议


TCP协议叫做传输控制协议（Transmission Control Protocol），TCP协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。

TCP协议是面向连接的，如果两台主机之间想要进行数据传输，那么必须要先建立连接，当连接建立成功后才能进行数据传输。其次，TCP协议是保证可靠的协议，数据在传输过程中如果出现了丢包、乱序等情况，TCP协议都有对应的解决方法。

> UDP协议


UDP协议叫做用户数据报协议（User Datagram Protocol），UDP协议是一种无需建立连接的、不可靠的、面向数据报的传输层通信协议。

使用UDP协议进行通信时无需建立连接，如果两台主机之间想要进行数据传输，那么直接将数据发送给对端主机就行了，但这也就意味着UDP协议是不可靠的，数据在传输过程中如果出现了丢包、乱序等情况，UDP协议本身是不知道的。

> 既然UDP协议是不可靠的，那为什么还要有UDP协议的存在？


TCP协议是一种可靠的传输协议，使用TCP协议能够在一定程度上保证数据传输时的可靠性，而UDP协议是一种不可靠的传输协议，UDP协议的存在有什么意义？

首先，可靠是需要我们做更多的工作的，TCP协议虽然是一种可靠的传输协议，但这一定意味着TCP协议在底层需要做更多的工作，因此TCP协议底层的实现是比较复杂的，我们不能只看到TCP协议面向连接可靠这一个特点，我们也要能看到TCP协议对应的缺点。

同样的，UDP协议虽然是一种不可靠的传输协议，但这一定意味着UDP协议在底层不需要做过多的工作，因此UDP协议底层的实现一定比TCP协议要简单，UDP协议虽然不可靠，但是它能够快速的将数据发送给对方，虽然在数据在传输的过程中可能会出错。

编写网络通信代码时具体采用TCP协议还是UDP协议，完全取决于上层的应用场景。如果应用场景严格要求数据在传输过程中的可靠性，此时我们就必须采用TCP协议，如果应用场景允许数据在传输出现少量丢包，那么我们肯定优先选择UDP协议，因为UDP协议足够简单。

**注意：** 一些优秀的网站在设计网络通信算法时，会同时采用TCP协议和UDP协议，当网络流畅时就使用UDP协议进行数据传输，而当网速不好时就使用TCP协议进行数据传输，此时就可以动态的调整后台数据通信的算法。


<a name="ElWHU"></a>
## 网络字节序

> 网络中的大小端问题


计算机在存储数据时是有大小端的概念的：

- **大端模式：** 数据的高字节内容保存在内存的低地址处，数据的低字节内容保存在内存的高地址处。
- **小端模式：** 数据的高字节内容保存在内存的高地址处，数据的低字节内容保存在内存的低地址处。

如果编写的程序只在本地机器上运行，那么是不需要考虑大小端问题的，因为同一台机器上的数据采用的存储方式都是一样的，要么采用的都是大端存储模式，要么采用的都是小端存储模式。但如果涉及网络通信，那就必须考虑大小端的问题，否则对端主机识别出来的数据可能与发送端想要发送的数据是不一致的。

例如，现在两台主机之间在进行网络通信，其中发送端是小端机，而接收端是大端机。发送端将发送缓冲区中的数据按内存地址从低到高的顺序发出后，接收端从网络中获取数据依次保存在接收缓冲区时，也是按内存地址从低到高的顺序保存的。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678453865635-34af6832-0d10-4a6e-8cc6-de501ca2ba5d.png#averageHue=%23ecece5&clientId=u2e10b020-8b48-4&from=paste&height=535&id=ufb9afe4e&name=image.png&originHeight=669&originWidth=1797&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=114312&status=done&style=none&taskId=ubf6e9c8f-71e4-48d7-a765-8e73729e3eb&title=&width=1437.6)

但由于发送端和接收端采用的分别是小端存储和大端存储，此时对于内存地址从低到高为44332211的序列，发送端按小端的方式识别出来是0x11223344，而接收端按大端的方式识别出来是0x44332211，此时接收端识别到的数据与发送端原本想要发送的数据就不一样了，这就是由于大小端的偏差导致数据识别出现了错误。

由于我们不能保证通信双方存储数据的方式是一样的，因此网络当中传输的数据必须考虑大小端问题。因此TCP/IP协议规定，网络数据流采用大端字节序，即低地址高字节。无论是大端机还是小端机，都必须按照TCP/IP协议规定的网络字节序来发送和接收数据。

- 如果发送端是小端，需要先将数据转成大端，然后再发送到网络当中。
- 如果发送端是大端，则可以直接进行发送。
- 如果接收端是小端，需要先将接收到数据转成小端后再进行数据识别。
- 如果接收端是大端，则可以直接进行数据识别。

在这个例子中，由于发送端是小端机，因此在发送数据前需要先将数据转成大端，然后再发送到网络当中，而由于接收端是大端机，因此接收端接收到数据后可以直接进行数据识别，此时接收端识别出来的数据就与发送端原本想要发送的数据相同了。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678453909770-0ac38713-eb55-40f6-bd5a-8a0bb065cc0e.png#averageHue=%23ecece5&clientId=u2e10b020-8b48-4&from=paste&height=548&id=u9c01680f&name=image.png&originHeight=685&originWidth=1796&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=125366&status=done&style=none&taskId=u0970da82-023f-4284-a5f0-48c637f1b96&title=&width=1436.8)

需要注意的是，所有的大小端的转化工作是由操作系统来完成的，因为该操作属于通信细节，不过也有部分的信息需要我们自行进行处理，比如端口号和IP地址。

> 为什么网络字节序采用的是大端？而不是小端？


网络字节序采用的是大端，而主机字节序一般采用的是小端，那为什么网络字节序不采用小端呢？如果网络字节序采用小端的话，发送端和接收端在发生和接收数据时就不用进行大小端的转换了。

该问题有很多不同说法，下面列举了两种说法：

- **说法一：** TCP在Unix时代就有了，以前Unix机器都是大端机，因此网络字节序也就采用的是大端，但之后人们发现用小端能简化硬件设计，所以现在主流的都是小端机，但协议已经不好改了。
- **说法二：** 大端序更符合现代人的读写习惯。


> 网络字节序与主机字节序之间的转换


为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，系统提供了四个函数，可以通过调用以下库函数实现网络字节序和主机字节序之间的转换。
```cpp
#include <arpa/inet.h>

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);

```

- 函数名当中的h表示host，n表示network，l表示32位长整数，s表示16位短整数。
- 例如htonl表示将32位长整数从主机字节序转换为网络字节序。
- 如果主机是小端字节序，则这些函数将参参数做相应的大小端转换然后返回。
- 如果主机是大端字节序，则这些函数不做任何转换，将参数原封不动的返回。

<a name="m469E"></a>
# socket编程接口
<a name="Pg1IG"></a>
## socket常见API

创建套接字：（TCP/UDP，客户端+服务器）<br />`int socket(int domain, int type, int protocol);`

绑定端口号：（TCP/UDP，服务器）<br />`int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`

监听套接字：（TCP，服务器）<br />`int listen(int sockfd, int backlog);`

接收请求：（TCP，服务器）<br />`int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`

建立连接：（TCP，客户端）<br />`int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`


<a name="qDm5a"></a>
## sockaddr结构

> sockaddr结构的出现


套接字不仅支持跨网络的进程间通信，还支持本地的进程间通信（域间套接字）。在进行跨网络通信时我们需要传递的端口号和IP地址，而本地通信则不需要，因此套接字提供了sockaddr_in结构体和sockaddr_un结构体，其中sockaddr_in结构体是用于跨网络通信的，而sockaddr_un结构体是用于本地通信的。

为了让套接字的网络通信和本地通信能够使用同一套函数接口，于是就出现了sockeaddr结构体，该结构体与sockaddr_in和sockaddr_un的结构都不相同，但这三个结构体头部的16个比特位都是一样的，这个字段叫做协议家族。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678533294754-584739b5-9e0e-4799-ba3f-e3f6e4cb522f.png#averageHue=%23fafafa&clientId=u17ab7c13-12d2-4&from=paste&height=596&id=uc6327a4e&name=image.png&originHeight=745&originWidth=1120&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33055&status=done&style=none&taskId=u92f218e2-4c1e-4d44-be4a-1351f9e0375&title=&width=896)<br />此时当我们在传递在传参时，就不用传入**sockeaddr_in**或**sockeaddr_un**这样的结构体，而统一传入**sockeaddr**这样的结构体。在设置参数时就可以通过设置协议家族这个字段，来表明我们是要进行网络通信还是本地通信，在这些API内部就可以提取**sockeaddr**结构头部的16位进行识别，进而得出我们是要进行网络通信还是本地通信，然后执行对应的操作。此时我们就通过通用**sockaddr**结构，将套接字网络通信和本地通信的参数类型进行了统一。

**注意**： 实际我们在进行网络通信时，定义的还是**sockaddr_in**这样的结构体，只不过在传参时需要将该结构体的地址类型进行强转为**sockaddr***罢了。


> 为什么会有这么多本地进程间通信的方式？


本地进程间通信的方式已经有管道、消息队列、共享内存、信号量等方式了，现在在套接字这里又出现了可以用于本地进程间通信的域间套接字，为什么会有这么多通信方式，并且这些通信方式好像并不相关？

实际是因为早期有很多不同的实验室都在研究通信的方式，由于是不同的实验室，因此就出现了很多不同的通信方式，比如常见的有System V标准的通信方式和POSIX标准的通信方式。

- IPv4和IPv6的地址格式定义在netinet/in.h中，IPv4地址用sockaddr_in结构体表示，包括16位地址类型，16位端口号和32位IP地址。
- IPv4、IPv6地址类型分别定义为常数AF_INET、AF_INET6。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。
- socket API可以都用struct sockaddr* 类型表示，在使用的时候需要强制转化成sockaddr_in；这样的好处是程序的通用性，可以接收IPv4、IPv6，以及UNIX Domain Socket各种类型的sockaddr结构体指针做为参数。


> 为什么没有用void*代替struct sockaddr*类型？


我们可以将这些函数的struct sockaddr*参数类型改为void*，此时在函数内部也可以直接指定提取头部的16个比特位进行识别，最终也能够判断是需要进行网络通信还是本地通信，那为什么还要设计出sockaddr这样的结构呢？

实际在设计这一套网络接口的时候C语言还不支持void*，于是就设计出了sockaddr这样的解决方案。并且在C语言支持了void*之后也没有将它改回来，因为这些接口是系统接口，系统接口是所有上层软件接口的基石，系统接口是不能轻易更改的，否则引发的后果是不可想的，这也就是为什么现在依旧保留sockaddr结构的原因。

<a name="KDBgQ"></a>
# 简单的UDP网络程序
<a name="atjg7"></a>
## 服务端创建套接字
我们把服务器封装成一个类，当我们定义出一个服务器对象后需要马上初始化服务器，而初始化服务器需要做的第一件事就是创建套接字。

> socket函数

创建套接字的函数叫做socket，该函数的函数原型如下：<br />`int socket(int domain, int type, int protocol);`

参数说明：

- domain：创建套接字的域或者叫做协议家族，也就是创建套接字的类型。该参数就相当于struct sockaddr结构的前16个位。如果是本地通信就设置为AF_UNIX，如果是网络通信就设置为AF_INET（IPv4）或AF_INET6（IPv6）。
- type：创建套接字时所需的服务类型。其中最常见的服务类型是SOCK_STREAM和SOCK_DGRAM，如果是基于UDP的网络通信，我们采用的就是SOCK_DGRAM，叫做用户数据报服务，如果是基于TCP的网络通信，我们采用的就是SOCK_STREAM，叫做流式套接字，提供的是流式服务。
- protocol：创建套接字的协议类别。你可以指明为TCP或UDP，但该字段一般直接设置为0就可以了，设置为0表示的就是默认，此时会根据传入的前两个参数自动推导出你最终需要使用的是哪种协议。

返回值说明：

- 套接字创建成功返回一个文件描述符，创建失败返回-1，同时错误码会被设置。


> socket函数属于什么类型的接口？


网络协议栈是分层的，按照TCP/IP四层模型来说，自顶向下依次是应用层、传输层、网络层和数据链路层。而我们现在所写的代码都叫做用户级代码，也就是说我们是在应用层编写代码，因此我们调用的实际是下三层的接口，而传输层和网络层都是在操作系统内完成的，也就意味着我们在应用层调用的接口都叫做系统调用接口。

> socket函数是被谁调用的？


socket这个函数是被程序调用的，但并不是被程序在编码上直接调用的，而是程序编码形成的可执行程序运行起来变成进程，当这个进程被CPU调度执行到socket函数时，然后才会执行创建套接字的代码，也就是说socket函数是被进程所调用的。

> socket函数底层做了什么？


**socket**函数是被进程所调用的，而每一个进程在系统层面上都有一个进程地址空间**PCB（task_struct）**、文件描述符表**（files_struct）**以及对应打开的各种文件。而文件描述符表里面包含了一个数组**fd_array**，其中数组中的0、1、2下标依次对应的就是标准输入、标准输出以及标准错误。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678533765789-54406554-cf7e-4e62-a50d-3d722b485de6.png#averageHue=%23f7f6f6&clientId=u17ab7c13-12d2-4&from=paste&height=355&id=u4a37836d&name=image.png&originHeight=444&originWidth=1129&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26942&status=done&style=none&taskId=uc32e3eaf-028a-4c36-9963-aa3baeff537&title=&width=903.2)


当我们调用socket函数创建套接字时，实际相当于我们打开了一个“网络文件”，打开后在内核层面上就形成了一个对应的**struct file**结构体，同时该结构体被连入到了该进程对应的文件双链表，并将该结构体的首地址填入到了**fd_array**数组当中下标为3的位置，此时**fd_array**数组中下标为3的指针就指向了这个打开的“网络文件”，最后3号文件描述符作为socket函数的返回值返回给了用户。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678533865058-27605892-d899-4d3f-8681-a42042fb6bc4.png#averageHue=%23f7f7f7&clientId=u17ab7c13-12d2-4&from=paste&height=429&id=ua11a61da&name=image.png&originHeight=536&originWidth=1218&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32962&status=done&style=none&taskId=u19620e16-8859-4f1b-9f7c-76bed4dfe0b&title=&width=974.4)


其中每一个**struct file**结构体中包含的就是对应打开文件各种信息，比如文件的属性信息、操作方法以及文件缓冲区等。其中文件对应的属性在内核当中是由**struct inode**结构体来维护的，而文件对应的操作方法实际就是一堆的函数指针（比如**read***和**write***）在内核当中就是由**struct file_operations**结构体来维护的。而文件缓冲区对于打开的普通文件来说对应的一般是磁盘，但对于现在打开的“网络文件”来说，这里的文件缓冲区对应的就是网卡。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678533947148-3ddc28fc-3c8c-428e-a4d4-573d41bc57be.png#averageHue=%23f7f6f6&clientId=u17ab7c13-12d2-4&from=paste&height=450&id=uf0c41e6c&name=image.png&originHeight=563&originWidth=1795&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=46278&status=done&style=none&taskId=uc7e7705a-d3ce-4adf-9e08-5b824973642&title=&width=1436)

对于一般的普通文件来说，当用户通过文件描述符将数据写到文件缓冲区，然后再把数据刷到磁盘上就完成了数据的写入操作。而对于现在socket函数打开的“网络文件”来说，当用户将数据写到文件缓冲区后，操作系统会定期将数据刷到网卡里面，而网卡则是负责数据发送的，因此数据最终就发送到了网络当中。


> 服务端创建套接字

当我们在进行初始化服务器创建套接字时，就是调用socket函数创建套接字，创建套接字时我们需要填入的协议家族就是AF_INET，因为我们要进行的是网络通信，而我们需要的服务类型就是SOCK_DGRAM，因为我们现在编写的UDP服务器是面向数据报的，而第三个参数之间设置为0即可。
```cpp
class UdpServer
{
public:
	bool InitServer()
	{
		//创建套接字
		_sockfd = socket(AF_INET, SOCK_DGRAM, 0);
		if (_sockfd < 0){ //创建套接字失败
			std::cerr << "socket error" << std::endl;
			return false;
		}

		std::cout << "socket create success, sockfd: " << _sockfd << std::endl;
		
		return true;
	}
	~UdpServer()
	{
		if (_sockfd >= 0){
			close(_sockfd);
		}
	};
private:
	int _sockfd; //文件描述符
};

```
**注意：** 当析构服务器时，我们可以将sockfd对应的文件进行关闭，但实际上不进行该操作也行，因为一般服务器运行后是就不会停下来的。<br />这里我们可以做一个简单的测试，看看套接字是否创建成功。
```cpp
int main()
{
	UdpServer* svr = new UdpServer();
	svr->InitServer();
	return 0;
}

```
运行程序后可以看到套接字是创建成功的，对应获取到的文件描述符就是3，这也很好理解，因为0、1、2默认被标准输入流、标准输出流和标准错误流占用了，此时最小的、未被利用的文件描述符就是3。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678675247000-6ad8a385-7da8-4ac6-8e83-f79e5ac8748a.png#averageHue=%23060403&clientId=u410cfb33-d832-4&from=paste&height=89&id=uedb8e12f&name=image.png&originHeight=111&originWidth=945&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=11173&status=done&style=none&taskId=u0c92e19f-85c7-42fc-928f-90325db19b6&title=&width=756)

<a name="e1qx3"></a>
## 服务端绑定
现在套接字已经创建成功了，但作为一款服务器来讲，如果只是把套接字创建好了，那我们也只是在系统层面上打开了一个文件，操作系统将来并不知道是要将数据写入到磁盘还是刷到网卡，此时该文件还没有与网络关联起来。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678675288158-f56ab5fd-3ff7-414f-aadb-c980beed56b6.png#averageHue=%23f7f6f6&clientId=u410cfb33-d832-4&from=paste&height=451&id=u3fd2b6ad&name=image.png&originHeight=564&originWidth=1793&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48151&status=done&style=none&taskId=uc9819b1e-348f-4ee7-8a4f-3aba79d940f&title=&width=1434.4)

由于现在编写的是不面向连接的UDP服务器，所以初始化服务器要做的第二件事就是绑定。

> bind函数

绑定的函数叫做bind，该函数的函数原型如下：<br />`int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`<br />参数说明：

- sockfd：绑定的文件的文件描述符。也就是我们创建套接字时获取到的文件描述符。
- addr：网络相关的属性信息，包括协议家族、IP地址、端口号等。
- addrlen：传入的addr结构体的长度。

返回值说明：

- 绑定成功返回0，绑定失败返回-1，同时错误码会被设置。
- <br />
> struct sockaddr_in结构体


在绑定时需要将网络相关的属性信息填充到一个结构体当中，然后将该结构体作为**bind**函数的第二个参数进行传入，这实际就是**struct sockaddr_in**结构体。<br />我们可以用**grep**命令在**/usr/include**目录下查找该结构，此时就可以找到定义该结构的文件。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678675515816-8b0df61b-078f-41eb-8e1b-0b01d9efe4d3.png#averageHue=%230d0806&clientId=u410cfb33-d832-4&from=paste&height=51&id=B8BUi&name=image.png&originHeight=64&originWidth=760&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8568&status=done&style=none&taskId=u04ed8b11-43c6-4456-a622-1ca9ca44e28&title=&width=608)<br />在该文件中就可以找到struct sockaddr_in结构的定义，需要注意的是，struct sockaddr_in属于系统级的概念，不同的平台接口设计可能会有点差别。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678675577751-3b89ce53-8b05-4b5a-99fb-17e4859e2349.png#averageHue=%23211f1e&clientId=u410cfb33-d832-4&from=paste&height=481&id=u1b7d010a&name=image.png&originHeight=601&originWidth=1471&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=195772&status=done&style=none&taskId=u40b0a2a9-75fe-4888-9f59-eeec28e2f52&title=&width=1176.8)<br />可以看到，struct sockaddr_in当中的成员如下：

- sin_family：表示协议家族。
- sin_port：表示端口号，是一个16位的整数。
- sin_addr：表示IP地址，是一个32位的整数。

剩下的字段一般不做处理，当然你也可以进行初始化。

其中sin_addr的类型是struct in_addr，实际该结构体当中就只有一个成员，该成员就是一个32位的整数，IP地址实际就是存储在这个整数当中的。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678675623592-64a8a810-d275-49da-9cde-cedb44e521b0.png#averageHue=%23201f1f&clientId=u410cfb33-d832-4&from=paste&height=158&id=u1019cae2&name=image.png&originHeight=198&originWidth=759&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=32562&status=done&style=none&taskId=ubdf36c2d-5014-4dcc-9a22-6e39a3f1809&title=&width=607.2)


> 如何理解绑定？

在进行绑定的时候需要将IP地址和端口号告诉对应的网络文件，此时就可以改变网络文件当中文件操作函数的指向，将对应的操作函数改为对应网卡的操作方法，此时读数据和写数据对应的操作对象就是网卡了，所以绑定实际上就是将文件和网络关联起来。

> 增加IP地址和端口号

由于绑定时需要用到IP地址和端口号，因此我们需要在服务器类当中引入IP地址和端口号，在创建服务器对象时需要传入对应的IP地址和端口号，此时我们就可以根据传入的IP地址和端口号对对应的成员进行初始化。
```cpp
class UdpServer
{
public:
	UdpServer(std::string ip, int port)
		:_sockfd(-1)
		,_port(port)
		,_ip(ip)
	{};
	~UdpServer()
	{
		if (_sockfd >= 0){
			close(_sockfd);
		}
	};
private:
	int _sockfd; //文件描述符
	int _port; //端口号
	std::string _ip; //IP地址
};

```
**注意：** 虽然这里端口号定义为整型，但由于端口号是16位的，因此我们实际只会用到它的低16位。

> 服务端绑定

套接字创建完毕后我们就需要进行绑定了，但在绑定之前我们需要先定义一个struct sockaddr_in结构，将对应的网络属性信息填充到该结构当中。由于该结构体当中还有部分选填字段，因此我们最好在填充之前对该结构体变量里面的内容进行清空，然后再将协议家族、端口号、IP地址等信息填充到该结构体变量当中。

需要注意的是，在发送到网络之前需要将端口号设置为网络序列，由于端口号是16位的，因此我们需要使用前面说到的htons函数将端口号转为网络序列。此外，由于网络当中传输的是整数IP，我们需要调用inet_addr函数将字符串IP转换成整数IP，然后再将转换后的整数IP进行设置。

当网络属性信息填充完毕后，由于bind函数提供的是通用参数类型，因此在传入结构体地址时还需要将struct sockaddr_in*强转为struct sockaddr*类型后再进行传入。
```cpp
class UdpServer
{
public:
	UdpServer(std::string ip, int port)
		:_sockfd(-1)
		,_port(port)
		,_ip(ip)
	{};
	bool InitServer()
	{
		//创建套接字
		_sockfd = socket(AF_INET, SOCK_DGRAM, 0);
		if (_sockfd < 0){ //创建套接字失败
			std::cerr << "socket error" << std::endl;
			return false;
		}

		std::cout << "socket create success, sockfd: " << _sockfd << std::endl;

		//填充网络通信相关信息
		struct sockaddr_in local;
		memset(&local, '\0', sizeof(local));
		local.sin_family = AF_INET;
		local.sin_port = htons(_port);
		local.sin_addr.s_addr = inet_addr(_ip.c_str());                                                                                                                                                                                                                                                                                                                                                                                                        

		//绑定
		if (bind(_sockfd, (struct sockaddr*)&local, sizeof(sockaddr)) < 0){ //绑定失败
			std::cerr << "bind error" << std::endl;
			return false;
		}

		std::cout << "bind success" << std::endl;

		return true;
	}
	~UdpServer()
	{
		if (_sockfd >= 0){
			close(_sockfd);
		}
	};
private:
	int _sockfd; //文件描述符
	int _port; //端口号
	std::string _ip; //IP地址
};

```
<a name="WXQP2"></a>
## 字符串IP VS 整数IP
IP地址的表现形式有两种：

- 字符串IP：类似于192.168.233.123这种字符串形式的IP地址，叫做基于字符串的点分十进制IP地址。
- 整数IP：IP地址在进行网络传输时所用的形式，用一个32位的整数来表示IP地址。


> 整数IP存在的意义


网络传输数据时是寸土寸金的，如果我们在网络传输时直接以基于字符串的点分十进制IP的形式进行IP地址的传送，那么此时一个IP地址至少就需要15个字节，但实际并不需要耗费这么多字节。

IP地址实际可以划分为四个区域，其中每一个区域的取值都是0~255，而这个范围的数字只需要用8个比特位就能表示，因此我们实际只需要32个比特位就能够表示一个IP地址。其中这个32位的整数的每一个字节对应的就是IP地址中的某个区域，我们将IP地址的这种表示方法称之为整数IP，此时表示一个IP地址只需要4个字节。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678675918123-a4f6a795-df28-4c42-ac69-8380d9f0df9c.png#averageHue=%23f6f6f5&clientId=u410cfb33-d832-4&from=paste&height=234&id=uf4585096&name=image.png&originHeight=292&originWidth=770&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=8402&status=done&style=none&taskId=ude482afd-086d-4428-8108-97d08009f32&title=&width=616)<br />因为采用整数IP的方案表示一个IP地址只需要4个字节，并且在网络通信也能表示同样的含义，因此在网络通信时就没有用字符串IP而用的是整数IP，因为这样能够减少网络通信时数据的传送。

> 字符串IP和整数IP相互转换的方式


转换的方式有很多，比如我们可以定义一个位段A，位段A当中有四个成员，每个成员的大小都是8个比特位，这四个成员就依次表示IP地址的四个区域，一共32个比特位。

然后我们再定义一个联合体IP，该联合体当中有两个成员，其中一个是32位的整数，其代表的就是整数IP，还有一个就是位段A类型的成员，其代表的就是字符串IP。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1678676186622-1c4c3963-2e0c-4cb7-a3fa-ba20fd26a61f.png#averageHue=%23fafaf9&clientId=u410cfb33-d832-4&from=paste&height=374&id=u9b137d2c&name=image.png&originHeight=467&originWidth=1064&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=29403&status=done&style=none&taskId=uc47f81cf-2156-4a71-a736-ca2557eac05&title=&width=851.2)

由于联合体的空间是成员共享的，因此我们设置IP和读取IP的方式如下：

- 当我们想以整数IP的形式设置IP时，直接将其赋值给联合体的第一个成员就行了。
- 当我们想以字符串IP的形式设置IP时，先将字符串分成对应的四部分，然后将每部分转换成对应的二进制序列依次设置到联合体中第二个成员当中的p1、p2、p3和p4就行了。
- 当我们想取出整数IP时，直接读取联合体的第一个成员就行了。
- 当我们想取出字符串IP时，依次获取联合体中第二个成员当中的p1、p2、p3和p4，然后将每一部分转换成字符串后拼接到一起就行了。

**注意：** 在操作系统内部实际用的就是位段和枚举，来完成字符串IP和整数IP之间的相互转换的。

> inet_addr函数

实际在进行字符串IP和整数IP的转换时，我们不需要自己编写转换逻辑，系统已经为我们提供了相应的转换函数，我们直接调用即可。<br />将字符串IP转换成整数IP的函数叫做inet_addr，该函数的函数原型如下：<br />`in_addr_t inet_addr(const char *cp);`

该函数使用起来非常简单，我们只需传入待转换的字符串IP，该函数返回的就是转换后的整数IP。除此之外，inet_aton函数也可以将字符串IP转换成整数IP，不过该函数使用起来没有inet_addr简单。

> inet_ntoa函数

将整数IP转换成字符串IP的函数叫做inet_ntoa，该函数的函数原型如下：<br />`char *inet_ntoa(struct in_addr in);`<br />需要注意的是，传入inet_ntoa函数的参数类型是in_addr，因此我们在传参时不需要选中in_addr结构当中的32位的成员传入，直接传入in_addr结构体即可。

<a name="zy14v"></a>
## 运行服务器
UDP服务器的初始化就只需要创建套接字和绑定就行了，当服务器初始化完毕后我们就可以启动服务器了。

服务器实际上就是在周而复始的为我们提供某种服务，服务器之所以称为服务器，是因为服务器运行起来后就永远不会退出，因此服务器实际执行的是一个死循环代码。由于UDP服务器是不面向连接的，因此只要UDP服务器启动后，就可以直接读取客户端发来的数据。
> recvfrom函数


UDP服务器读取数据的函数叫做recvfrom，该函数的函数原型如下：<br />`ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);`

参数说明：

- sockfd：对应操作的文件描述符。表示从该文件描述符索引的文件当中读取数据。
- buf：读取数据的存放位置。
- len：期望读取数据的字节数。
- flags：读取的方式。一般设置为0，表示阻塞读取。
- src_addr：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。
- addrlen：调用时传入期望读取的src_addr结构体的长度，返回时代表实际读取到的src_addr结构体的长度，这是一个输入输出型参数。

返回值说明：

- 读取成功返回实际读取到的字节数，读取失败返回-1，同时错误码会被设置。

注意：

- 由于UDP是不面向连接的，因此我们除了获取到数据以外还需要获取到对端网络相关的属性信息，包括IP地址和端口号等。
- 在调用recvfrom读取数据时，必须将addrlen设置为你要读取的结构体对应的大小。
- 由于recvfrom函数提供的参数也是struct sockaddr*类型的，因此我们在传入结构体地址时需要将struct sockaddr_in*类型进行强转。

> 启动服务器函数


现在服务端通过recvfrom函数读取客户端数据，我们可以先将读取到的数据当作字符串看待，将读取到的数据的最后一个位置设置为'\0'，此时我们就可以将读取到的数据进行输出，同时我们也可以将获取到的客户端的IP地址和端口号也一并进行输出。

需要注意的是，我们获取到的客户端的端口号此时是网络序列，我们需要调用ntohs函数将其转为主机序列再进行打印输出。同时，我们获取到的客户端的IP地址是整数IP，我们需要通过调用inet_ntoa函数将其转为字符串IP再进行打印输出。
```cpp
class UdpServer
{
public:
	void Start()
	{
#define SIZE 128
		char buffer[SIZE];
		for (;;){
			struct sockaddr_in peer;
			socklen_t len = sizeof(peer);
			ssize_t size = recvfrom(_sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&peer, &len);
			if (size > 0){
				buffer[size] = '\0';
				int port = ntohs(peer.sin_port);
				std::string ip = inet_ntoa(peer.sin_addr);
				std::cout << ip << ":" << port << "# " << buffer << std::endl;
			}
			else{
				std::cerr << "recvfrom error" << std::endl;
			}
		}
	}
private:
	int _sockfd; //文件描述符
	int _port; //端口号
	std::string _ip; //IP地址
};

```
**注意：** 如果调用recvfrom函数读取数据失败，我们可以打印一条提示信息，但是不要让服务器退出，服务器不能因为读取某一个客户端的数据失败就退出。

> 引入命令行参数


鉴于构造服务器时需要传入IP地址和端口号，我们这里可以引入命令行参数。此时当我们运行服务器时在后面跟上对应的IP地址和端口号即可。

由于云服务器的原因，后面实际不需要传入IP地址，因此在运行服务器的时候我们只需要传入端口号即可，目前我们就手动将IP地址设置为127.0.0.1。IP地址为127.0.0.1实际上等价于localhost表示本地主机，我们将它称之为本地环回，相当于我们一会先在本地测试一下能否正常通信，然后再进行网络通信的测试。
```cpp
int main(int argc, char* argv[])
{
	if (argc != 2){
		std::cerr << "Usage: " << argv[0] << " port" << std::endl;
		return 1;
	}
	std::string ip = "127.0.0.1"; //本地环回
	int port = atoi(argv[1]);
	UdpServer* svr = new UdpServer(ip, port);
	svr->InitServer();
	svr->Start();
	return 0;
}

```
需要注意的是，agrv数组里面存储的是字符串，而端口号是一个整数，因此需要使用atoi函数将字符串转换成整数。然后我们就可以用这个IP地址和端口号来构造服务器了，服务器构造完成并初始化后就可以调用Start函数启动服务器了。

此时带上端口号运行程序就可以看到套接字创建成功、绑定成功，现在服务器就在等待客户端向它发送数据![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1679310606114-59e16583-dbaf-4747-add7-278ab23f0cd0.png#averageHue=%23070503&clientId=u54f69fa6-0a8a-4&from=paste&height=118&id=u9ae3a022&name=image.png&originHeight=147&originWidth=645&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=10116&status=done&style=none&taskId=ud5235cc5-82c4-4451-9afa-e63108a86c0&title=&width=516)<br />虽然现在客户端代码还没有编写，但是我们可以通过netstat命令来查看当前网络的状态，这里我们可以选择携带nlup选项。

netstat常用选项说明：

- -n：直接使用IP地址，而不通过域名服务器。
- -l：显示监控中的服务器的Socket。
- -t：显示TCP传输协议的连线状况。
- -u：显示UDP传输协议的连线状况。
- -p：显示正在使用Socket的程序识别码和程序名称。

此时你就能查看到对应网络相关的信息，在这些信息中程序名称为./udp_server的那一行显示的就是我们运行的UDP服务器的网络信息。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1679310736304-1711e232-4735-4e0c-ab7f-fa686b9f0747.png#averageHue=%2315100e&clientId=u54f69fa6-0a8a-4&from=paste&height=455&id=u95dd17ea&name=image.png&originHeight=569&originWidth=1206&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=48246&status=done&style=none&taskId=u9ba1f7e6-c81a-44e0-98a9-1ad856e3eef&title=&width=964.8)

你可以尝试去掉-n选项再查看，此时原本显示IP地址的地方就变成了对应的域名服务器。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1679310788667-8a0f53ae-5f9a-4f52-8b97-e73f638b571c.png#averageHue=%23100c0b&clientId=u54f69fa6-0a8a-4&from=paste&height=644&id=ub2eadd4e&name=image.png&originHeight=805&originWidth=1351&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=73850&status=done&style=none&taskId=uda5d0153-21dc-4ffb-8f06-43e0e72a286&title=&width=1080.8)

其中netstat命令显示的信息中，Proto表示协议的类型，Recv-Q表示网络接收队列，Send-Q表示网络发送队列，Local Address表示本地地址，Foreign Address表示外部地址，State表示当前的状态，PID表示该进程的进程ID，Program name表示该进程的程序名称。

其中Foreign Address写成0.0.0.0:*表示任意IP地址、任意的端口号的程序都可以访问当前进程。

<a name="dMbcz"></a>
## 客户端创建套接字
同样的，我们把客户端也封装成一个类，当我们定义出一个客户端对象后也是需要对其进行初始化，而客户端在初始化时也需要创建套接字，之后客户端发送数据或接收数据也就是对这个套接字进行操作。

客户端创建套接字时选择的协议家族也是AF_INET，需要的服务类型也是SOCK_DGRAM，当客户端被析构时也可以选择关闭对应的套接字。与服务端不同的是，客户端在初始化时只需要创建套接字就行了，而不需要进行绑定操作。
```cpp
class UdpClient
{
public:
	bool InitClient()
	{
		//创建套接字
		_sockfd = socket(AF_INET, SOCK_DGRAM, 0);
		if (_sockfd < 0){
			std::cerr << "socket create error" << std::endl;
			return false;
		}
		return true;
	}
	~UdpClient()
	{
		if (_sockfd >= 0){
			close(_sockfd);
		}
	}
private:
	int _sockfd; //文件描述符
};

```

<a name="x5QjI"></a>
## 关于客户端的绑定问题
首先，由于是网络通信，通信双方都需要找到对方，因此服务端和客户端都需要有各自的IP地址和端口号，只不过服务端需要进行端口号的绑定，而客户端不需要。

因为服务器就是为了给别人提供服务的，因此服务器必须要让别人知道自己的IP地址和端口号，IP地址一般对应的就是域名，而端口号一般没有显示指明过，因此服务端的端口号一定要是一个众所周知的端口号，并且选定后不能轻易改变，否则客户端是无法知道服务端的端口号的，这就是服务端要进行绑定的原因，只有绑定之后这个端口号才真正属于自己，因为一个端口只能被一个进程所绑定，服务器绑定一个端口就是为了独占这个端口。

而客户端在通信时虽然也需要端口号，但客户端一般是不进行绑定的，客户端访问服务端的时候，端口号只要是唯一的就行了，不需要和特定客户端进程强相关。

如果客户端绑定了某个端口号，那么以后这个端口号就只能给这一个客户端使用，就是这个客户端没有启动，这个端口号也无法分配给别人，并且如果这个端口号被别人使用了，那么这个客户端就无法启动了。所以客户端的端口只要保证唯一性就行了，因此客户端端口可以动态的进行设置，并且客户端的端口号不需要我们来设置，当我们调用类似于sendto这样的接口时，操作系统会自动给当前客户端获取一个唯一的端口号。

也就是说，客户端每次启动时使用的端口号可能是变化的，此时只要我们的端口号没有被耗尽，客户端就永远可以启动。


<a name="uaiMl"></a>
## 启动客户端
> 增加服务端IP地址和端口号

作为一个客户端，它必须知道它要访问的服务端的IP地址和端口号，因此在客户端类当中需要引入服务端的IP地址和端口号，此时我们就可以根据传入的服务端的IP地址和端口号对对应的成员进行初始化。
```cpp
class UdpClient
{
public:
	UdpClient(std::string server_ip, int server_port)
		:_sockfd(-1)
		,_server_port(server_port)
		,_server_ip(server_ip)
	{}
	~UdpClient()
	{
		if (_sockfd >= 0){
			close(_sockfd);
		}
	}
private:
	int _sockfd; //文件描述符
	int _server_port; //服务端端口号
	std::string _server_ip; //服务端IP地址
};

```
当客户端初始化完毕后我们就可以将客户端运行起来，由于客户端和服务端在功能上是相互补充的，既然服务器是在读取客户端发来的数据，那么客户端就应该想服务端发送数据。

> sendto函数

UDP客户端发送数据的函数叫做sendto，该函数的函数原型如下：<br />`ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);`

参数说明：

- sockfd：对应操作的文件描述符。表示将数据写入该文件描述符索引的文件当中。
- buf：待写入数据的存放位置。
- len：期望写入数据的字节数。
- flags：写入的方式。一般设置为0，表示阻塞写入。
- dest_addr：对端网络相关的属性信息，包括协议家族、IP地址、端口号等。 addrlen：传入dest_addr结构体的长度。

返回值说明：

- 写入成功返回实际写入的字节数，写入失败返回-1，同时错误码会被设置。

**注意：**

- 由于UDP不是面向连接的，因此除了传入待发送的数据以外还需要指明对端网络相关的信息，包括IP地址和端口号等。
- 由于sendto函数提供的参数也是struct sockaddr*类型的，因此我们在传入结构体地址时需要将struct sockaddr_in*类型进行强转。

> 启动客户端函数


现在客户端要发送数据给服务端，我们可以让客户端获取用户输入，不断将用户输入的数据发送给服务端。

需要注意的是，客户端中存储的服务端的端口号此时是主机序列，我们需要调用htons函数将其转为网络序列后再设置进struct sockaddr_in结构体。同时，客户端中存储的服务端的IP地址是字符串IP，我们需要通过调用inet_addr函数将其转为整数IP后再设置进struct sockaddr_in结构体。
```cpp
class UdpClient
{
public:
	void Start()
	{
		std::string msg;
		struct sockaddr_in peer;
		memset(&peer, '\0', sizeof(peer));
		peer.sin_family = AF_INET;
		peer.sin_port = htons(_server_port);
		peer.sin_addr.s_addr = inet_addr(_server_ip.c_str());

		for (;;){
			std::cout << "Please Enter# ";
			getline(std::cin, msg);
			sendto(_sockfd, msg.c_str(), msg.size(), 0, (struct sockaddr*)&peer, sizeof(peer));
		}
	}
private:
	int _sockfd; //文件描述符
	int _server_port; //服务端端口号
	std::string _server_ip; //服务端IP地址
};

```


> 引入命令行参数

鉴于构造客户端时需要传入对应服务端的IP地址和端口号，我们这里也可以引入命令行参数。当我们运行客户端时直接在后面跟上对应服务端的IP地址和端口号即可。
```cpp
int main(int argc, char* argv[])
{
	if (argc != 3){
		std::cerr << "Usage: " << argv[0] << " server_ip server_port" << std::endl;
		return 1;
	}
	std::string server_ip = argv[1];
	int server_port = atoi(argv[2]);
	UdpClient* clt = new UdpClient(server_ip, server_port);
	clt->InitClient();
	clt->Start();
	return 0;
}

```
需要注意的是，argv数组里面存储的是字符串，而端口号是一个整数，因此需要使用atoi函数将字符串转换成整数。然后我们就可以用这个IP地址和端口号来构造客户端了，客户端构造完成并初始化后就可以调用Start函数启动客户端了。

<a name="axfxt"></a>
## 本地测试
现在服务端和客户端的代码都已经编写完毕，我们可以先进行本地测试，此时服务器没有绑定外网，绑定的是本地环回。现在我们运行服务器时指明端口号为8081，再运行客户端，此时客户端要访问的服务器的IP地址就是本地环回127.0.0.1，服务端的端口号就是8081。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1679312197999-895dfa4e-5446-40e7-b96c-180efd3a683a.png#averageHue=%233b3938&clientId=u54f69fa6-0a8a-4&from=paste&height=81&id=ud5f620af&name=image.png&originHeight=101&originWidth=1208&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=26365&status=done&style=none&taskId=u71e1b0a0-60a6-494c-94be-2cd3f2f1dc5&title=&width=966.4)

客户端运行之后提示我们进行输入，当我们在客户端输入数据后，客户端将数据发送给服务端，此时服务端再将收到的数据打印输出，这时我们在服务端的窗口也看到我们输入的内容。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1679312219683-aa3b3859-111e-402f-a01d-b78761c2139f.png#averageHue=%230d0c0b&clientId=u54f69fa6-0a8a-4&from=paste&height=77&id=u3203bb45&name=image.png&originHeight=96&originWidth=1209&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=42039&status=done&style=none&taskId=ua2fa700b-7366-4374-8a8a-268887a8977&title=&width=967.2)

此时我们再用netstat命令查看网络信息，可以看到服务端的端口是8081，客户端的端口是53979。这里客户端能被netstat命令查看到，说明客户端也已经动态绑定成功了，这就是我们所谓的网络通信。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1679312483317-f8c5aacd-9158-4b30-8b1f-81ab41c7c60c.png#averageHue=%23060505&clientId=u54f69fa6-0a8a-4&from=paste&height=489&id=uaa8d4646&name=image.png&originHeight=611&originWidth=1081&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=33681&status=done&style=none&taskId=u3a34cdd1-2b5e-45ea-a83b-2276c9f2ad4&title=&width=864.8)

<a name="bHWkq"></a>
## INADDR_ANY
现在我们已经通过了本地测试，接下来就需要进行网络测试了，那是不是直接让服务端绑定我的公网IP，此时这个服务端就能够被外网访问了呢？<br />理论上确实是这样的，就比如我的服务器的公网IP是1.117.89.227，这里用ping命令也是能够ping通的。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1679313029184-33d6b836-ad4a-4842-bc6c-d8348cd6b0d6.png#averageHue=%230f0c09&clientId=u54f69fa6-0a8a-4&from=paste&height=118&id=u5fec58c2&name=image.png&originHeight=148&originWidth=667&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=16435&status=done&style=none&taskId=u83788bdd-20bb-4c34-8062-011e1d6b4f5&title=&width=533.6)<br />现在我将服务端设置的本地环回改为我的公网IP，此时当我们重新编译程序再次运行服务端的时候会发现服务端绑定失败。

由于云服务器的IP地址是由对应的云厂商提供的，这个IP地址并不一定是真正的公网IP，这个IP地址是不能直接被绑定的，如果需要让外网访问，此时我们需要bind 0。系统当当中提供的一个**INADDR_ANY**，这是一个宏值，它对应的值就是0。<br />因此如果我们需要让外网访问，那么在云服务器上进行绑定时就应该绑定**INADDR_ANY**，此时我们的服务器才能够被外网访问。

> 绑定INADDR_ANY的好处


当一个服务器的带宽足够大时，一台机器接收数据的能力就约束了这台机器的IO效率，因此一台服务器底层可能装有多张网卡，此时这台服务器就可能会有多个IP地址，但一台服务器上端口号为8081的服务只有一个。这台服务器在接收数据时，这里的多张网卡在底层实际都收到了数据，如果这些数据也都想访问端口号为8081的服务。此时如果服务端在绑定的时候是指明绑定的某一个IP地址，那么此时服务端在接收数据的时候就只能从绑定IP对应的网卡接收数据。而如果服务端绑定的是INADDR_ANY，那么只要是发送给端口号为8081的服务的数据，系统都会可以将数据自底向上交给该服务端。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1679313130406-e68198f9-1459-489f-9ba3-c73d04c5e28c.png#averageHue=%23f6f5f5&clientId=u54f69fa6-0a8a-4&from=paste&height=420&id=ud86ca34d&name=image.png&originHeight=525&originWidth=1424&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=18806&status=done&style=none&taskId=u071fb79b-c413-450a-8c3f-5a7832e0ba8&title=&width=1139.2)

因此服务端绑定INADDR_ANY这种方案也是强烈推荐的方案，所有的服务器具体在操作的时候用的也就是这种方案。<br />当然，如果你既想让外网访问你的服务器，但你又指向绑定某一个IP地址，那么就不能用云服务器，此时可以选择使用虚拟机或者你自定义安装的Linux操作系统，那个IP地址就是支持你绑定的，而云服务器是不支持的。


<a name="nfuFb"></a>
# 简易的回声服务器
由于在进行网络测试的时候，当客户端发送数据给服务端时，服务端会将从客户端收到的数据进行打印，因此服务端是能够看到现象的。但客户端一直在向服务端发送数据，在客户端这边看不出服务端是否收到了自己发送的数据。

> 服务端代码编写


鉴于此，我们可以将该服务器改成一个简单的回声服务器。当服务端收到客户端发来的数据后，除了在服务端进行打印以外，服务端可以调用sento函数将收到的数据重新发送给对应的客户端。

需要注意的是，服务端在调用sendto函数时需要传入客户端的网络属性信息，但服务端现在是知道客户端的网络属性信息的，因为服务端在此之前就已经通过recvfrom函数获取到了客户端的网络属性信息。
```cpp
void Start()
{
#define SIZE 128
	char buffer[SIZE];
	for (;;){
		struct sockaddr_in peer;
		socklen_t len = sizeof(peer);
		ssize_t size = recvfrom(_sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&peer, &len);
		if (size > 0){
			buffer[size] = '\0';
			int port = ntohs(peer.sin_port);
			std::string ip = inet_ntoa(peer.sin_addr);
			std::cout << ip << ":" << port << "# " << buffer << std::endl;
		}
		else{
			std::cerr << "recvfrom error" << std::endl;
		}

		std::string echo_msg = "server get!->";
		echo_msg += buffer;
		sendto(_sockfd, echo_msg.c_str(), echo_msg.size(), 0, (struct sockaddr*)&peer, len);
	}
}

```


> 客户端代码编写


服务端的代码改了之后，对应客户端的代码也得改改。当客户端发完数据给服务端后，由于服务端还会将该数据重新发给客户端，因此客户端发完数据后还需要调recvfrom来读取服务端发来的响应数据。

在客户端调用recvfrom函数接收服务端发来的响应数据时，客户端同时也需要读取服务端与网络相关的各种信息。虽然客户端早已知道服务端的网络信息了，此时服务端的网络信息已经不重要了，但还是建议不要把参数设置为空，这样可能会出问题，所以我们还是用一个临时变量将服务端的网络信息读取一下。

而客户端接收到服务端的响应数据后，将数据原封不动的打印出来就行了。此时客户端发送给服务端的数据，除了在服务端会打印显示以外，服务端还会将数据再重新发回给客户端，此时客户端也会接收到响应数据然后将该数据进行打印。
```cpp
void Start()
{
	std::string msg;
	struct sockaddr_in peer;
	memset(&peer, '\0', sizeof(peer));
	peer.sin_family = AF_INET;
	peer.sin_port = htons(_server_port);
	peer.sin_addr.s_addr = inet_addr(_server_ip.c_str());

	for (;;){
		std::cout << "Please Enter# ";
		getline(std::cin, msg);
		sendto(_sockfd, msg.c_str(), msg.size(), 0, (struct sockaddr*)&peer, sizeof(peer));
		
#define SIZE 128
		char buffer[SIZE];
		struct sockaddr_in tmp;
		socklen_t len = sizeof(tmp);
		ssize_t size = recvfrom(_sockfd, buffer, sizeof(buffer)-1, 0, (struct sockaddr*)&tmp, &len);
		if (size > 0){
			buffer[size] = '\0';
			std::cout << buffer << std::endl;
		}
	}
}

```

<a name="LL2PR"></a>
## 网络测试
> 静态编译客户端

我们可以将生成的客户端的可执行程序发送给你的其他朋友，进行网络级别的测试。为了保证程序在你们的机器是严格一致的，可以选择在编译客户端时携带-static选项进行静态编译。![image.png](https://cdn.nlark.com/yuque/0/2023/png/29339358/1679313287016-16aa0f0c-5d58-46e8-b082-c91db99f4c2f.png#averageHue=%23232120&clientId=u54f69fa6-0a8a-4&from=paste&height=391&id=u923864e2&name=image.png&originHeight=489&originWidth=847&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37851&status=done&style=none&taskId=u4d3d3ea5-2744-4c02-b937-0cb8b42351a&title=&width=677.6)

> 分发客户端

此时我们可以先使用sz命令将该客户端可执行程序下载到本地机器，然后将该程序发送给你的朋友。而我们分发客户端的过程实际上就是我们在网上下载各种PC端软件的过程，我们下软件下的实际上就是客户端的可执行程序，而与之对应的服务端就在Linux服务器上部署着。

当你的朋友收到这个客户端的可执行程序后，可以通过rz命令或拖拽的方式将这个可执行程序上传到他的云服务器上，然后通过chmod命令给该文件加上可执行权限。
